С помощью хука `useMemo` можно указать какую функцию мемоизировать и при каком условии. Не стоит путать с `React.memo` (компонент высшего порядка).
Мемоизация сохраняет результат выполнения функции, чтобы в последующем выполнять её только тогда, когда это действительно нужно.
`useMemo` работает по типу `useEffect` - принимает 2 параметра:
1. Функция
2. Массив зависимостей
Но различие между ними в том, что `useMemo` будет выполнять функцию и её результат возвращать, при этом будет следить за зависимостями. Если зависимости изменяются - только тогда эта функция будет выполняться.
Когда эта функция выполниться, результат вернётся, то `useMemo` сохранит этот результат и будет возвращать его каждый раз, если зависимости не меняются.
Перейдем к примеру:
```
const [count, setCount] = useState(1);

function theBigTask(n) {
	while (n < 6000000000) n++;
	return n;
}

return (
	<div>
		<p>Count: {count}</p>
		<p>Number: {theBigTask(1)}</p>
		<p>{count === 5 ? '5' : '!5'}</p>
		<button onClick={() => setCount(count + 1)}>Increment</button>
	</div>
);

```

У нас есть компонент-счётчик. Каждый раз когда мы нажимаем на кнопку у нас вызывается функция, которая от 1 проходит до 6 миллиардов и при это весь интерфейс очень сильно тормозит. Задача - оптимизировать это. На помощь к нам приходит хук `useMemo`:
```
const memoizedTask = useMemo(() => theBigTask(1), []);

return (
	<div>
		<p>Count: {count}</p>
		<p>Number: {memoizedTask}</p>
		<p>{count === 5 ? '5' : '!5'}</p>
		<button onClick={() => setCount(count + 1)}>Increment</button>
	</div>
);
```

В этом случае мы вызываем функцию внутри `useMemo` и присваиваем это всё константе `memoizedTask`, которую и передаём в разметку. После этих действий счётчик больше не тормозит.