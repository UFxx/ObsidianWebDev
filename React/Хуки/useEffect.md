Этот хук используется для замены некоторых методов жизненного цикла компонента, таких как:
- Визуализация компонента (componentDidMount в классовом компоненте)
- Обновление компонента (componentDidUpdated в классовом компоненте)
- Удаление компонента (componentWillUnmount в классовом компоненте)
А также несколько побочных явлений:
- Получение данных; 
- Прямое обновление DOM;
- Установка заголовка страницы;
- Работа с setInterval или setTimeout;
- Измерение ширины, высоты или положения элементов в DOM;
- Установка или получение значений в локальном хранилище.
- Подписка на услуги и её отмена
```
useEffect(() => {
  fetch(`http://127.0.0.1:8000/api-timetable/timetable/${group}/`)
	.then(response => response.json())
	.then(data => {
		setData(data.timetable);
	})
})
```

# Массив зависимостей
`useEffect` принимает 2 параметра: 
- Первый - функция обратного вызова, для которой мы будем выполнять побочных эффекты:
```
function MyComponent() {
  useEffect(() => {
    // Этот эффект будет запускаться после каждого рендера
  })
}
```

- Второй - массив зависимостей:
```
function MyComponent() {
  useEffect(() => {
    // Этот эффект будет запускать один раз после рендера
  }, [])
}
```

Если мы не передаём второй аргумент, побочный эффект в функции сработает только один раз при первой визуализации.

Если мы всё же передаём свойства или значения состояния во втором аргументе, побочный эффект будет выполнять только при изменении значений свойств или переменной состояния:
```
import { useEffect, useState } from 'react'
function MyComponent({ prop }) {
   const [state, setState] = useState('')
   useEffect(() => {
      // Этот эффект будет запускать каждый раз, когда что-нибудь из массива зависимостей меняется
   }, [prop, state])
}
```

# Функция очистки
Второй аргумент позволяет запускать побочные эффекты при монтировании и обновлении компонента. Но нам нужно запускать их и тогда, когда компонент размонтирован. Функция очистки позволяет остановить побочные эффекты перед размонтированием компонента.
```
function MyComponent() {
  useEffect(() => {
    // Этот побочный эффект будет запущен после каждого рендера
    return () => {
      // Этот побочный эффект будет запуещ после размонтирования компонента
    }
  })
}
```

# Бесконечный цикл
При освоении `useEffect` можно случайно получить бесконечный цикл в следующих случаях:
- Не указан массив зависимостей.
Это происходит потому что состояние изменяется при визуализации компонента. Поскольку состояние изменилось, компонент визуализируется.
- В массиве зависимостей указана функция.
- Использование функций `Async-Await`.
Если мы хотим получать данные с помощью API, нам нужно выполнять асинхронные операции. Есть 3 пути решения:
1. Создать асинхронную функцию вне `useEffect` и вызвать её в `useEffect`:
```
const getPosts = async () => {
 const {data} = await axios.get('api/posts')
 setPosts(data)
}
useEffect(() => {
 getUsers()
}, [])
```

2. Создать асинхронную операцию в `useEffect` и вызвать её в `useEffect`:
```
useEffect(() => {
const getPosts = async () => {
 const {data} = await axios.get('api/posts')
 setPosts(data)
}
 getUsers()
}, [])
```

3. Использовать IIFE в `useEffect`:
```
useEffect(() => {
  (async () => {
    const {data} = await axios.get('api/posts')
    setPosts(data)
  })()
}, [])
```

[[Хуки]]