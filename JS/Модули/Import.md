# Import
`Import` позволяет импортировать ранее [экспортированные](Export) [функции](Функции) / переменные / [классы](Классы). Происходит это следующим образом:
```
// Передаем список того, что хотим импортировать
import { sayHi, sayBye } from './export.js';

// Вызов импортированных функций
sayHi('Name');
sayBye('Name');
```

# Import *
Так же, если импортировать нужно много чего, то можно воспользоваться следующим методом:
```
// Импортируем всё, что экспортируется из модуля
import * as say from './export.js';

// Вызов импортированных функций
say.sayHi('Name');
say.sayBye('Name');
```

Это выглядит удобно, и казалось бы, можно использовать только второй метод. Но есть несколько причин этого не делать:
1. Современные сборщики собирают все модули вместе и оптимизируют их, ускоряя загрузку удаляя неиспользуемый код. Предположим, что мы добавили в наш проект библиотеку `say.js` и импортировали оттуда 1 [функцию](Функции). Тогда оптимизатор увидит, что другие функции не используются и удалит их, тем самым делая код меньше. Это называется tree-shaking.
2. Явно перечисляя то, что мы хотим импортировать мы получаем более короткие имена [функций](Функции).
3. Явное перечисление импортов делает код более понятным. Это упрощает поддержку и рефакторинг кода.

# Import as
Также можно использовать `as`, чтобы импортировать что-либо с другим именем:
```
import { sayHi as hi, sayBye as bye } from './export.js';

hi('Name');
bye('Name');
```