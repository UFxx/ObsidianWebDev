# EventLoop
EventLoop - бесконечный цикл задач. Он ожидает задачи, выполняет их, а затем снова ожидает новых задач.

Пример #1:
```
console.log('first');
console.log('second');

// Вывод:
// -> first
// -> second
```

**Пояснение**
[JS](JS) - интерпретируемый язык, это говорит о том, что код он исполняется сверху вниз построчно (то есть строка за строкой). Благодаря этому мы получили такой вывод (Пример #1).

Пример #2:
```
function fistFunction () {
	console.log('log1');
	console.log('log2');
}

function secondFunction () {
	console.log('log3');
	firstFunction();
}
secondFunction();

// Вывод:
// -> log3
// -> log1
// -> log2
```

**Пояснение**
В примере #2 мы создали `firstFunction`, которая выводит в консоль `log1` и `log2`, но не вызвали её. Затем создали `secondFunction`, которая выводит в консоль `log3` и вызывает `firstFunction`. Таким образом мы получим вывод в консоль: `log3`, `log1`, `log2`, потому что первую [функцию](Функции) мы не вызвали сами по себе, а вызвали во второй [функции](Функции), но во второй [функции](Функции) перед вызовом первой идем `log3`, а лишь потом вызов второй [функции](Функции), что и дало такой результат.

Пример #3:
```
console.log('start');

function someFunction () {
	setTimeout (function callback () {
		console.log('inside timeout');
	}, 3000)
	console.log('inside someFunction')
}

someFunction();
console.log('end');

// Вывод:
// -> start
// -> inside someFunction
// -> end
// -> inside timeout
```

**Пояснение**
Изначально выводится `start`, потому что он первый, затем идет вызов `someFunction`, где в свою очередь в `setTimeout` вызывается `callback` [функция](Функции)с таймером в 3 секунды, которая выводит `inside timeout`, а затем выводится `inside someFunction`. После этого всего выводится `end`. По идее должно быть так, но `setTimeout` является асинхронной [функцией](Функции), поэтому она будет выполняться после выполнения синхронного кода и поэтому мы получаем такой вывод. Даже если мы установим таймер в `setTimeout` на 0, код внутри `setTimeout` выведет `inside timeout` только после выполнения остального кода.

# Работа EventLoop'а
Чтобы понять работу EventLoop нужно представить 3 контейнера:

![[Group 1.png]]

Допустим у нас на сайте есть обработчик события и `setTimeout` на 3 секунды. При заходе на страницу, функции предоставленные браузером попадают в Call Stack (стек вызовов), а затем оттуда в Web API (функции, предоставляемые не [JS](JS), а веб-браузером). После истечения 3-х секунд `setTimeout` попадет в Task Queue (очередь задач) и если в Call Stack не вызываются синхронные функции, то `setTimeout` попадет в Call Stack и будет выполнен. 

<hr>

**Пояснение**
`setTimeout` является асинхронным, а задачи из Task Queue выполняются только после выполнения всех синхронных задач в Call Stack.

<hr>

В случае с обработчиками событий происходит тоже самое. Сначала они из Call Stack попадают в Web API и "висят" там до того, как событие, на которое они должны реагировать произойдет. Затем, когда событие произошло они попадают в Task Queue и если в Call Stack нет синхронных задач - они выполняются.

# Macro && Micro Tasks
На самом деле Task Queue разделяется еще на 2 "контейнера":
1. Macrotasks (очередь событий). Сюда попадают:
	1. Promise
	2. queueMicrotask
	3. [mutationObserver](MutationObserver)
2. Microtasks (очередь задач). Сюда попадают:
	1. Таймеры (`setInterval`, `setTimeout`)
	2. События (`click`, загрузка изображения и так далее)
	3. Браузерные нюансы (рендер, input, output, и что-либо под капотом браузера)

![[Group 1 (1).png]]

Macro и Micro задачи выполняются следующим образом:
	Сначала выполняются все Micro задачи, а потом только одна Macro задача.

**Примечание**
